{
  "version": 3,
  "sources": ["../src/tee.ts", "../src/lazy-iterator.ts", "../src/lazy-async-iterator.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * Creates multiple independent lazy iterators from a single iterable source, allowing parallel consumption without re-traversing the source.\n * Each returned iterator is will yield the same sequence of values as the original iterable, but can be consumed at different rates.\n * Each returned iterator is lazy and only consumes values from the source iterable as they are requested.\n *\n * @template T - The type of elements in the source iterable.\n * @param {Iterable<T>} sourceIterable - The iterable to split into multiple iterators.\n * @param {number} count - The number of independent iterators to create.\n * @returns {IterableIterator<T>[]} An array of independent iterators over the source iterable.\n * @throws {Error} If incorrect arguments are provided or the source is not iterable.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const [it1, it2] = Array.tee(arr, 2);\n * console.log(it1.next().value); // 1\n * console.log(it2.next().value); // 1\n * console.log(it1.next().value); // 2\n * console.log(it2.next().value); // 2\n */\nexport function createTeeIterators<T>(sourceIterable: Iterable<T>, count: number): IterableIterator<T>[] {\n    if(arguments.length !== 2) throw new Error(`Expected 2 arguments but recieved: ${arguments.length}`);\n    if(!sourceIterable[Symbol.iterator]) throw new Error(`Expected Arg 1 to be an iterator.`)\n    if(!(typeof count === \"number\")) throw new Error(`Expected Arg 2 to be an integer`)\n\n    // Make it an integer\n    count = Math.floor(count)\n\n    const sourceIterator = sourceIterable[Symbol.iterator]();\n    const iteratorIndexPositions: number[] = Array(count).fill(0);\n    const streamBuffer: T[] = []\n    \n    let streamExhausted = false;\n    let streamError: Error | null = null;\n\n    /**\n     * Gets the next value from the source iterator, handling exhaustion and errors.\n     */\n    function getNextStreamElement() {\n        if(streamExhausted) return { value: undefined, done: true};\n        if(streamError) throw streamError;\n\n        try {\n            const result = sourceIterator.next();\n            if(result.done) streamExhausted = true;\n            // console.log('result',result)\n            return result;\n        } catch(e) {\n            streamError = e as any as Error;\n            throw e\n        }  \n    }\n\n    /**\n     * Cleans up the buffer by removing elements already consumed by all iterators.\n     */\n    function cleanupStreamBuffer() {\n        const smallestComsumedIndex = Math.min(...iteratorIndexPositions)\n        const deletedElementsCount = smallestComsumedIndex;\n        streamBuffer.splice(0, deletedElementsCount);\n        for(let i = 0; i < count; i++) {\n            iteratorIndexPositions[i] -= deletedElementsCount;\n        }\n    }\n\n    /**\n     * Creates a single teed iterator for the given index.\n     */\n    function createTeedIterator(index: number): IterableIterator<T> {\n        let done = false\n        return {\n            [Symbol.iterator]() {\n                return this\n            },\n            next(): IteratorResult<T> {\n                if(done) return { value: undefined, done: true}\n\n                // console.log(`Before`)\n                // console.log(`iterator ${index}`)\n                // console.log(\"buffer\", streamBuffer)\n                // console.log(`index position: ${iteratorIndexPositions[index]}`)\n                \n                if(iteratorIndexPositions[index] < streamBuffer.length) {\n                    const value = streamBuffer[iteratorIndexPositions[index]];\n                    iteratorIndexPositions[index]++;\n                    cleanupStreamBuffer();\n                    return { value, done: false }\n                }\n\n                const result = getNextStreamElement()\n\n                if(result.done) {\n                    done = true;\n                    return {done: true, value: undefined}\n                }\n\n                // console.log(\"pushed to stream\");\n                streamBuffer.push(result.value!);\n                // console.log(\"index incremented\")\n                iteratorIndexPositions[index]++\n                cleanupStreamBuffer();\n\n                // console.log(\"After\")\n                // console.log(`iterator ${index}`)\n                // console.log(\"buffer\", streamBuffer)\n                // console.log(`index position: ${iteratorIndexPositions[index]}`)\n\n                return { value: result.value!, done: false }\n\n            },\n            return(value) {\n                if(!done) {\n                    done = true;\n                }\n                return { value, done}\n            },\n            throw(e) {\n                if(!done) {\n                    done = true;\n                }\n                throw e\n            }\n        }   \n    }\n\n    return Array(count).fill(0).map((_, idx) => createTeedIterator(idx))\n}\n\n\n/** Shared buffer and position helpers for tee iterators (sync/async) */\nfunction makeTeeBufferHelpers(count: number) {\n    const iteratorIndexPositions: number[] = Array(count).fill(0);\n    const streamBuffer: any[] = [];\n    return {\n        iteratorIndexPositions,\n        streamBuffer,\n        cleanupStreamBuffer() {\n            const smallestConsumedIndex = Math.min(...iteratorIndexPositions);\n            const deletedElementsCount = smallestConsumedIndex;\n            streamBuffer.splice(0, deletedElementsCount);\n            for (let i = 0; i < count; i++) {\n                iteratorIndexPositions[i] -= deletedElementsCount;\n            }\n        }\n    };\n}\n\n/**\n * Creates multiple independent lazy async iterators from a single async iterable/iterator source.\n * Each returned async iterator yields the same sequence of values as the original, but can be consumed at different rates.\n * @template T\n * @param {AsyncIterable<T>|AsyncIterator<T>} sourceAsyncIterable - The async iterable/iterator to split.\n * @param {number} count - The number of async iterators to create.\n * @returns {AsyncIterableIterator<T>[]} An array of independent async iterators.\n * @throws {Error} If incorrect arguments are provided or the source is not async iterable/iterator.\n */\nexport function createAsyncTeeIterators<T>(sourceAsyncIterable: AsyncIterable<T> | AsyncIterator<T>, count: number): AsyncIterableIterator<T>[] {\n    if (arguments.length !== 2) throw new Error(`Expected 2 arguments but received: ${arguments.length}`);\n    if (!sourceAsyncIterable || (typeof sourceAsyncIterable !== 'object')) throw new Error(`Expected Arg 1 to be an async iterable or async iterator.`);\n    if (!(typeof count === 'number')) throw new Error(`Expected Arg 2 to be an integer`);\n    count = Math.floor(count);\n\n    // Get async iterator from input\n    let sourceIterator: AsyncIterator<T>;\n    if (typeof (sourceAsyncIterable as any)[Symbol.asyncIterator] === 'function') {\n        sourceIterator = (sourceAsyncIterable as AsyncIterable<T>)[Symbol.asyncIterator]();\n    } else if (typeof (sourceAsyncIterable as any).next === 'function') {\n        sourceIterator = sourceAsyncIterable as AsyncIterator<T>;\n    } else {\n        throw new Error('Source is not async iterable or async iterator');\n    }\n\n    const { iteratorIndexPositions, streamBuffer, cleanupStreamBuffer } = makeTeeBufferHelpers(count);\n    let streamExhausted = false;\n    let streamError: Error | null = null;\n\n    async function getNextStreamElementAsync() {\n        if (streamExhausted) return { value: undefined, done: true };\n        if (streamError) throw streamError;\n        try {\n            const result = await sourceIterator.next();\n            if (result.done) streamExhausted = true;\n            return result;\n        } catch (e) {\n            streamError = e as any as Error;\n            throw e;\n        }\n    }\n\n    function createTeedAsyncIterator(index: number): AsyncIterableIterator<T> {\n        let done = false;\n        return {\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            async next(): Promise<IteratorResult<T>> {\n                if (done) return { value: undefined, done: true };\n                if (iteratorIndexPositions[index] < streamBuffer.length) {\n                    const value = streamBuffer[iteratorIndexPositions[index]];\n                    iteratorIndexPositions[index]++;\n                    cleanupStreamBuffer();\n                    return { value, done: false };\n                }\n                const result = await getNextStreamElementAsync();\n                if (result.done) {\n                    done = true;\n                    return { done: true, value: undefined };\n                }\n                streamBuffer.push(result.value!);\n                iteratorIndexPositions[index]++;\n                cleanupStreamBuffer();\n                return { value: result.value!, done: false };\n            },\n            async return(value) {\n                if (!done) {\n                    done = true;\n                }\n                return { value, done };\n            },\n            async throw(e) {\n                if (!done) {\n                    done = true;\n                }\n                throw e;\n            }\n        };\n    }\n\n    return Array(count).fill(0).map((_, idx) => createTeedAsyncIterator(idx));\n}\n\n\ntype ExtractReturnTypeFromFuncArray<T extends unknown[]> =\n  T extends  [infer First, ...infer Rest] ?\n    First extends (...args: any[]) => any ?\n      Rest extends ((...args: any[]) => any)[] ?\n        [ReturnType<First>, ...ExtractReturnTypeFromFuncArray<Rest>]\n      : never\n    : never\n  : [];\n\ntype ExtractFnFromTeeConsumer<T extends unknown[]> =\n    T extends [infer First, ...infer Rest] ?\n        First extends TeeConsumer<any,any> ?\n            Rest extends TeeConsumer<any,any>[] ?\n                [First['fn'], ...ExtractFnFromTeeConsumer<Rest>]\n            : never\n        : never\n    : [];\n\n// type TeeConsumerFn<T> = <T>(val: T, idx: number) => void\nexport type TeeConsumer<T,S=any> = {\n    fn: (val: T, idx: number) => S,\n    kind: 'map' \n} |\n{\n    fn: (val: T, idx: number) => boolean,\n    kind: 'filter'\n} | \n{\n    fn: (acc: S | number, curr: T, idx: number) => S | number,\n    kind: 'reduce',\n    initVal?: S | number \n} | \n{\n    fn: (val: T, idx: number) => void,\n    kind: 'forEach',\n};\n\ntype res = ExtractReturnTypeFromFuncArray<ExtractFnFromTeeConsumer<[\n    { fn: (val: number, idx: number) => string, kind: 'map'},\n    { fn: (acc: number, curr: number, idx: number) => number, kind: 'reduce', initVal?: number}\n]>>\n\n\n// type TeeConsumer<T,S=any> = TeeConsumerFn<T> | TeeConsumserConfigurable<T,S>\n\n /**\n * Applies multiple consumer operations (map, filter, reduce, forEach) in parallel to an array, using independent iterators for each consumer.\n * Each consumer receives elements and their index, and results are returned in an array matching the order of consumer\n * @throws {TypeError|Error} If invalid arguments or consumer configuration are provided.\n *\n * @example\n * const arr = [1,2,3];\n * const results = arr.tee(\n *   { kind: 'map', fn: (x, i) => x * 2 },\n *   { kind: 'filter', fn: (x, i) => x % 2 === 1 },\n *   { kind: 'reduce', fn: (acc, x, i) => acc + x, initVal: 0 },\n *   { kind: 'forEach', fn: (x, i) => console.log(x) }\n * );\n * // results: [[2,4,6], [1,3], 6, undefined]\n */\nexport function teeConsumers<T,S>(this: Array<T>, ...consumers: TeeConsumer<T,S>[]) {\n    // Runtime type checking for params\n    if (!Array.isArray(this)) {\n        throw new TypeError('teeConsumers must be called on an array');\n    }\n    if (!consumers.length) {\n        throw new Error('At least one consumer must be provided');\n    }\n    // Validate each consumer object\n    for (const consumer of consumers) {\n        if (typeof consumer !== 'object' || consumer === null) {\n            throw new TypeError('Each consumer must be an object');\n        }\n        if (!('kind' in consumer) || typeof consumer.kind !== 'string') {\n            throw new TypeError('Each consumer must have a string kind property');\n        }\n        if (typeof consumer.fn !== 'function') {\n            throw new TypeError('Each consumer must have a function fn property');\n        }\n        if (consumer.kind === 'reduce' && !('initVal' in consumer)) {\n            // Allow reduce without initVal\n        }\n    }\n\n    // Prepare iterators and results\n    const consumerFns = Array.from(consumers);\n    const outResults: any[] = Array(consumerFns.length).fill(0);\n    const iterators = createTeeIterators(this, consumerFns.length);\n\n    // Process each consumer in parallel\n    for (let consumerIdx = 0; consumerIdx < consumerFns.length; consumerIdx++) {\n        const fn = consumerFns[consumerIdx];\n        const mapResult: any[] = [];\n        let reduceResult: any = fn.kind === 'reduce' ? fn.initVal : undefined;\n        let filterResult: T[] = [];\n        let elementIdx = 0;\n        // Iterate through each element for this consumer\n        for(const elem of iterators[consumerIdx]) {\n            switch(fn.kind) {\n                case 'forEach':\n                    fn.fn(elem, elementIdx);\n                    break;\n                case 'map':\n                    {\n                        const val = fn.fn(elem, elementIdx);\n                        mapResult.push(val);\n                    }\n                    break;\n                case 'reduce':\n                    {\n                        if (elementIdx === 0 && reduceResult === undefined) {\n                            reduceResult = elem;\n                        } else {\n                            reduceResult = fn.fn(reduceResult, elem, elementIdx);\n                        }\n                    }\n                    break;\n                case 'filter':\n                    {\n                        if (fn.fn(elem, elementIdx))\n                            filterResult.push(elem);\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown consumer kind: ${String((fn as any).kind)}`);\n            }\n            elementIdx++;\n        }\n        // Store result for this consumer\n        switch(fn.kind) {\n            case 'forEach':\n                outResults[consumerIdx] = undefined;\n                break;\n            case 'reduce':\n                outResults[consumerIdx] = reduceResult;\n                break;\n            case 'map':\n                outResults[consumerIdx] = mapResult;\n                break;\n            case 'filter':\n                outResults[consumerIdx] = filterResult;\n                break;\n        }\n    }\n    // Return all results\n    return outResults as any[];\n}\n", "import {createTeeIterators} from './tee'\n\n/**\n * A function that maps a value and its index to a new value.\n */\ntype MapFunc<T,S> = (x: T, idx: number) => S;\n/**\n * A function that filters values based on a predicate.\n */\ntype FilterFunc<T,S extends any = any> = (x: T, idx: number) => boolean;\n/**\n * A function that performs a side effect for each value.\n */\ntype ForEachFunc<T,S extends any = any> = (x: T, idx: number) => void;\n/**\n * A function that reduces values to a single accumulated result.\n */\ntype ReduceFunc<T,S> = (acc: S, curr: T, idx: number) => S;\n\n\ntype IteratorMethods<T,S extends any = any> = \n  MapFunc<T,S> |\n  FilterFunc<T,S> |\n  ForEachFunc<T,S> |\n  ReduceFunc<T,S> |\n  Iterator<T>\n\n// type ExtractMapTypeFromFunc<T extends unknown[]> =\n//   T extends  [infer First, ...infer Rest] ?\n//     First extends (...args: any[]) => any ?\n//       Rest extends ((...args: any[]) => any)[] ?\n//         [ReturnType<First>, ...ExtractMapTypeFromFunc<Rest>]\n//       : never\n//     : never\n//   : [];\n\n\ntype GetLastMethodType<T extends any[]> = T extends readonly [...any[], infer Last] ? \n  Last extends Iterator<infer P> ?\n    readonly [P,P] \n      : Last extends IteratorMethods<infer Q, infer R> ?\n        readonly [Q, R]\n      : never\n    : never;\n\ntype Push<T extends any[], S extends any> = [...T, S];\n\n\n /**\n * A lazy, chainable iterator supporting map, filter, forEach, reduce, and other functional operations.\n *\n * Allows for efficient, composable data processing pipelines without creating intermediate arrays.\n *\n * @template IterType The type of elements in the iterator.\n * @template Methods The chain of methods applied to the iterator.\n *\n * @throws Error If constructed from null or undefined, or from an invalid iterator/iterable.\n * @throws Error If take(n) or drop(n) is called with a negative number.\n */\nexport class LazyIterator<IterType, Methods extends IteratorMethods<any,any>[] = [Iterator<IterType>]> implements IterableIterator<IterType> {\n    iterator: Iterator<IterType>;\n    _methods: {\n        fn: IteratorMethods<any,any>\n        kind: 'map' | 'reduce' | 'forEach' | 'filter',\n        initVal?: any\n    }[];\n\n    exhausted: boolean;\n    caughtError: Error | null;\n    index: number;\n\n    /**\n     * Creates a LazyIterator from an iterator or iterable.\n     *\n     * @throws Error If the input is null, undefined, or not an iterator/iterable.\n     */\n    static from<T>(iter: Iterator<T> | Iterable<T>) {\n        if(iter === undefined || iter === null) throw new Error(\"LazyIterator cannot be created from null or undefined\");\n        if('next' in iter && typeof iter.next === 'function') {\n            return new LazyIterator<T>(iter)\n        }\n\n        if (typeof iter === 'object' && Symbol.iterator in iter) {\n            const iterator = (iter as Iterable<T>)[Symbol.iterator]();\n            return new LazyIterator<T>(iterator);\n        }\n\n        throw new Error(\"Couldn't create LazyIterator. no valid iterator\");\n    }\n\n    /**\n     * Constructs a LazyIterator from a given iterator.\n     */\n    constructor(iterator: Iterator<IterType>) {\n        this.iterator = iterator;\n        this._methods = []\n        this.exhausted = false;\n        this.caughtError = null;\n        this.index = 0;\n    }\n\n    private executeFunctMethod<T>(method: {\n        fn: IteratorMethods<any,any>,\n        kind: 'map' | 'reduce' | 'forEach' | 'filter',\n        initVal?: any\n    }, val: T, index: number) {\n        switch(method.kind) {\n            case 'map':\n            case 'filter':\n            case 'forEach':\n                {\n                    const fn = method.fn as MapFunc<any,any> | FilterFunc<any,any> | ForEachFunc<any,any>;\n                    return fn(val, index)\n                }  \n            case 'reduce':\n                {\n                    const fn = method.fn as ReduceFunc<any,any>\n                    return fn({}, val, index)\n                }\n            default:\n                return {} as any\n        }\n    }\n\n    /**\n     * Returns the next value in the iterator, applying all chained methods.\n     *\n     * @throws Error If the iterator is already exhausted.\n     */\n    next(): IteratorResult<GetLastMethodType<Methods>[1],undefined> {\n        // if(this.methods.length === 0) return { done: true, value: undefined}; \n        if(this.exhausted) return { done: true, value: undefined} \n\n        while(true) {\n            const nextVal = this.iterator.next();\n        \n            if(nextVal.done) {\n                this.exhausted = true;\n                 return { done: true, value: undefined}\n            }\n\n            if(this._methods.length === 0) return { value: nextVal.value, done: false} as { value: GetLastMethodType<Methods>[1], done: false}\n\n            \n            let filterFail = false;\n            let a = nextVal.value;\n\n            for(let i = 0; i < this._methods.length; i++) {\n                let retVal = this.executeFunctMethod(this._methods[i], a, this.index)\n                \n                // console.log({ value: nextVal.value, retVal, kind: this.methods[i].kind});\n\n                if(this._methods[i].kind === 'map')\n                    a = retVal;\n                if(this._methods[i].kind === 'filter' && retVal === false) {\n                    filterFail = true;\n                    break\n                }\n            }\n\n\n            this.index++;\n\n            if(filterFail) continue;\n\n            return { done: false, value: a} as { value: GetLastMethodType<Methods>[1], done: false}\n        }\n        \n    }\n\n    /**\n     * Marks the iterator as exhausted and returns the given value.\n     */\n    return(value: any) {\n        if(!this.exhausted) {\n            this.exhausted = true;\n        }\n\n        return { value, done: this.exhausted }\n    }\n\n    /**\n     * Marks the iterator as exhausted due to an error.\n     */\n    throw(e: any) {\n        if(!this.exhausted) {\n            this.exhausted = true\n        }\n\n        return { done: this.exhausted, value: undefined}\n    }\n\n    /**\n     * Returns itself as an iterator.\n     */\n    [Symbol.iterator]() {\n        return this\n    } \n\n    /**\n     * Lazily maps each value using the provided callback.\n     */\n    map<S>(cb: MapFunc<GetLastMethodType<Methods>[1],S>) {\n        this._methods.push({\n            fn: cb,\n            kind: 'map'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, MapFunc<GetLastMethodType<Methods>[1],S>>>;\n    }\n\n    /**\n     * Lazily filters values using the provided predicate.\n     */\n    filter(cb: FilterFunc<GetLastMethodType<Methods>[1]>) {\n        this._methods.push({\n            fn: cb,\n            kind: 'filter'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, FilterFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily performs a side effect for each value using the provided callback.\n     *\n     * Note: Unlike Array.prototype.forEach, this does not terminate or consume the iterator. It is a pass-through operation and can be used for observability (e.g., logging, debugging) within a pipeline. The iterator continues to yield values downstream.\n     */\n    forEach(cb: ForEachFunc<GetLastMethodType<Methods>[1]>) {\n        this._methods.push({\n            fn: cb,\n            kind: 'forEach'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, ForEachFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily reduces values to a single result using the provided reducer and initial value.\n     */\n    reduce<S>(cb: ReduceFunc<GetLastMethodType<Methods>[1],S>, initVal: S) {\n        this._methods.push({\n            fn: cb,\n            kind: 'reduce',\n            initVal\n        })\n\n        const lazyIterator = this as unknown as LazyIterator<IterType, Push<Methods, ReduceFunc<GetLastMethodType<Methods>[1],S>>>\n\n        const reduceExec = new ReduceExecutor(lazyIterator);\n\n        return reduceExec;\n    }\n\n    /**\n     * Collects all values into an array.\n     */\n    toArray(): GetLastMethodType<Methods>[1][] {\n        return this.collect()\n    }\n\n    /**\n     * Creates multiple independent iterators (tees) from this iterator.\n     *\n     * @throws Error If count is not a positive integer.\n     */\n    tee(count: number) {\n        return createTeeIterators<GetLastMethodType<Methods>[1]>(this, count).map(v => LazyIterator.from(v))\n    }\n\n    /**\n     * Collects all values into an array (alias for toArray).\n     */\n    collect(): GetLastMethodType<Methods>[1][] {\n        const out: GetLastMethodType<Methods>[] = []\n        for(const elem of this) {\n            out.push(elem)\n        }\n        return out\n    }\n\n    /**\n     * Takes the first n values from the iterator.\n     *\n     * @throws Error If n is negative or not a number.\n     */\n    take(n: number): GetLastMethodType<Methods>[1][] {\n        if (typeof n !== 'number' || n < 0) throw new Error('take(n): n must be a non-negative number');\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let count = 0;\n        for (const elem of this) {\n            if (count++ >= n) break;\n            out.push(elem);\n        }\n        return out;\n    }\n\n    /**\n     * Skips the first n values from the iterator.\n     *\n     * @throws Error If n is negative or not a number.\n     */\n    drop(n: number): GetLastMethodType<Methods>[1][] {\n        if (typeof n !== 'number' || n < 0) throw new Error('drop(n): n must be a non-negative number');\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let count = 0;\n        for (const elem of this) {\n            if (count++ < n) continue;\n            out.push(elem);\n        }\n        return out;\n    }\n\n    /**\n     * Takes values while the predicate returns true.\n     */\n    takeWhile(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean): GetLastMethodType<Methods>[1][] {\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let idx = 0;\n        for (const elem of this) {\n            if (!predicate(elem, idx)) break;\n            out.push(elem);\n            idx++;\n        }\n        return out;\n    }\n\n    /**\n     * Skips values while the predicate returns true, then collects the rest.\n     */\n    dropWhile(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean): GetLastMethodType<Methods>[1][] {\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let idx = 0;\n        let dropping = true;\n        for (const elem of this) {\n            if (dropping && predicate(elem, idx)) {\n                idx++;\n                continue;\n            }\n            dropping = false;\n            out.push(elem);\n            idx++;\n        }\n        return out;\n    }\n}\n\ntype ExtractLazyIteratorMethods<T extends unknown> =\n    T extends LazyIterator<infer _, infer Q> \n    ? Q\n    : never;\n\n\n /**\n * Executes a reduce operation on a LazyIterator chain.\n */\nclass ReduceExecutor<R extends any, S extends IteratorMethods<any,any>, T extends LazyIterator<R, S[]>> {\n    private lazyIterator: T;\n\n    constructor(lazyIterator: T) {\n        this.lazyIterator = lazyIterator;\n    }\n\n    /**\n     * Executes the reduce operation and returns the result.\n     */\n    execute() {\n        const reduceMethod = this.lazyIterator._methods.at(-1)!;\n        this.lazyIterator._methods.slice(0,-1);\n        const array = this.lazyIterator.collect();\n        const result = array.reduce(reduceMethod.fn as unknown as ReduceFunc<GetLastMethodType<ExtractLazyIteratorMethods<T>>[0],GetLastMethodType<ExtractLazyIteratorMethods<T>>[1]>, reduceMethod.initVal);\n        return result as unknown as GetLastMethodType<ExtractLazyIteratorMethods<T>>[1]\n    }\n}\n", "import {createAsyncTeeIterators} from './tee';\n\n/**\n * A function that maps a value and its index to a new value (sync).\n */\ntype MapFunc<T,S> = (x: T, idx: number) => S;\n/**\n * A function that filters values based on a predicate (sync).\n */\ntype FilterFunc<T,S extends any = any> = (x: T, idx: number) => boolean;\n/**\n * A function that performs a side effect for each value (sync).\n */\ntype ForEachFunc<T,S extends any = any> = (x: T, idx: number) => void;\n/**\n * A function that reduces values to a single accumulated result (sync).\n */\ntype ReduceFunc<T,S> = (acc: S, curr: T, idx: number) => S;\n/**\n * A function that maps a value and its index to a new value (async).\n */\ntype MapAsyncFunc<T,S> = (x: T, idx: number) => Promise<S>\n/**\n * A function that filters values based on a predicate (async).\n */\ntype FilterAsyncFunc<T, S extends any = any> = (x: T, idx: number) => Promise<boolean>\n/**\n * A function that performs a side effect for each value (async).\n */\ntype ForEachAsyncFunc<T, S extends any = any> = (x: T, idx: number) => Promise<void>\n\ntype AsyncIterMethods<T,S> = \n    MapFunc<T,S> |\n    FilterFunc<T,S> |\n    ForEachFunc<T,S> |\n    ReduceFunc<T,S> |\n    MapAsyncFunc<T,S> |\n    FilterAsyncFunc<T,S> |\n    ForEachAsyncFunc<T,S> |\n    Iterator<T> |\n    AsyncIterator<T>;\n\ntype GetLastMethodType<T extends any[]> = \n    T extends [...any[], infer Last]\n    ?   Last extends Iterator<infer R> | AsyncIterator<infer R>\n        ? [R,R]\n        : Last extends AsyncIterMethods<infer P, infer Q>\n            ? [P,Q]\n            : never\n    : never;\n\ntype Push<T extends any[], S extends any> = [...T, S];\n\ntype AsyncChainMethod = { kind: 'mapAsync' | 'filterAsync' | 'forEachAsync', fn: MapAsyncFunc<any,any> | FilterAsyncFunc<any,any> | ForEachAsyncFunc<any,any> };\ntype SyncChainMethod = { kind: 'map' | 'filter' | 'forEach', fn: MapFunc<any,any> | FilterFunc<any,any> | ForEachFunc<any,any>};\ntype ReduceMethod = { kind: 'reduce', fn: ReduceFunc<any,any>, initVal?: any };\n\n/**\n * A lazy, chainable async iterator supporting both sync and async map, filter, forEach, reduce, and other functional operations.\n *\n * Allows for efficient, composable async data processing pipelines without creating intermediate arrays.\n *\n * @template IterType The type of elements in the iterator.\n * @template Methods The chain of methods applied to the iterator.\n *\n * @throws Error If constructed from null or undefined, or from an invalid iterator/iterable.\n * @throws Error If take(n), drop(n), takeSettled(n), or dropSettled(n) is called with a negative number.\n */\nexport class LazyAsyncIterator<IterType, Methods extends AsyncIterMethods<any,any>[] = [Iterator<IterType> | AsyncIterator<IterType>]> implements AsyncIterableIterator<IterType> {\n    iterator: Iterator<IterType> | AsyncIterator<IterType>;\n    methods: \n        (SyncChainMethod | AsyncChainMethod | ReduceMethod)[]\n\n    exhausted: boolean;\n    caughtError: Error | null;\n    index: number;\n\n    /**\n     * Constructs a LazyAsyncIterator from a given iterator or async iterator.\n     */\n    constructor(iterator: Iterator<IterType> | AsyncIterator<IterType>) {\n        this.iterator = iterator;\n        this.methods = [];\n        this.exhausted = false;\n        this.caughtError = null;\n        this.index = 0;\n    }\n\n    /**\n     * Creates a LazyAsyncIterator from an iterator, async iterator, iterable, or async iterable.\n     *\n     * @throws Error If the input is null, undefined, or not an iterator/iterable.\n     */\n    static from<T>(input: Iterator<T> | AsyncIterator<T> | Iterable<T> | AsyncIterable<T>): LazyAsyncIterator<T> {\n        if (input === undefined || input === null) {\n            throw new Error(\"LazyAsyncIterator cannot be created from null or undefined\");\n        }\n        // If it's an async iterator\n        if (typeof input === 'object' && 'next' in input && typeof input.next === 'function' && (Symbol.asyncIterator in input)) {\n            return new LazyAsyncIterator<T>(input as AsyncIterator<T>);\n        }\n        // If it's a sync iterator\n        if (typeof input === 'object' && 'next' in input && typeof input.next === 'function' && (Symbol.iterator in input)) {\n            return new LazyAsyncIterator<T>(input as Iterator<T>);\n        }\n        // If it's an async iterable\n        if (typeof input === 'object' && Symbol.asyncIterator in input) {\n            const iterator = (input as AsyncIterable<T>)[Symbol.asyncIterator]();\n            return new LazyAsyncIterator<T>(iterator);\n        }\n        // If it's a sync iterable\n        if (typeof input === 'object' && Symbol.iterator in input) {\n            const iterator = (input as Iterable<T>)[Symbol.iterator]();\n            return new LazyAsyncIterator<T>(iterator);\n        }\n        throw new Error(\"Couldn't create LazyAsyncIterator. No valid iterator or iterable provided.\");\n    }\n\n    private async getNextElement() {\n        if(Symbol.iterator in this.iterator || Symbol.asyncIterator in this.iterator)\n            return this.iterator.next()\n        return { done: true, value: undefined}\n    }\n\n    private async executeChainedMethod<T>(method: SyncChainMethod | AsyncChainMethod, value: T, index: number) {\n        return method.fn(value, index)\n    }\n\n    private executeReduceMethod<T>(method: ReduceMethod, value: T, index: number, initVal?: any) {\n        return method.fn(initVal, value, index)\n    }\n\n    [Symbol.asyncIterator]() {\n        return this\n    }\n    \n    /**\n     * Returns the next value in the iterator, applying all chained methods (sync and async).\n     *\n     * @throws Error If the iterator is already exhausted.\n     */\n    async next(): Promise<IteratorResult<GetLastMethodType<Methods>[1]>> {\n        if(this.exhausted) return { done: true, value: undefined };\n\n        while(true) {\n            const nextResult = await this.getNextElement();\n\n            if(nextResult.done) {\n                this.exhausted = true;\n                return { done: true, value: undefined }\n            }\n\n            if(this.methods.length === 0) return { done: false, value: nextResult.value } as { done: false, value: GetLastMethodType<Methods>[1]}; \n\n            let opResult = nextResult.value;\n            let filterFail = false;\n\n            for(const method of this.methods) {\n                let retVal;\n                if(method.kind !== \"reduce\") {\n                    retVal = await this.executeChainedMethod(method, opResult, this.index)\n                }\n                else {\n                    this.executeReduceMethod(method, opResult, this.index, method.initVal)\n                }\n\n                if(method.kind === 'map' || method.kind === 'mapAsync')\n                    opResult = retVal\n\n                if((method.kind === 'filter' || method.kind === 'filterAsync') && !retVal) {\n                    filterFail = true\n                    break;\n                }\n            }\n\n            this.index++;\n\n            if(filterFail) continue;\n\n            return { done: false, value: opResult } as { done: false, value: GetLastMethodType<Methods>[1]}\n        }\n    }\n\n    /**\n     * Marks the iterator as exhausted and returns the given value.\n     */\n    async return(value: any) {\n        if(!this.exhausted) {\n            this.exhausted = true;\n        }\n\n        return { value, done: this.exhausted }\n    }\n\n    /**\n     * Marks the iterator as exhausted due to an error.\n     */\n    async throw(e: any) {\n        if(!this.exhausted) {\n            this.exhausted = true\n        }\n\n        return { done: this.exhausted, value: undefined}\n    }\n\n    /**\n     * Lazily maps each value using the provided callback (sync).\n     */\n    map<S>(cb: MapFunc<GetLastMethodType<Methods>[1],S>) {\n        this.methods.push({\n            kind: 'map',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType,Push<Methods, MapFunc<GetLastMethodType<Methods>[1],S>>>\n    }\n\n    /**\n     * Lazily filters values using the provided predicate (sync).\n     */\n    filter(cb: FilterFunc<GetLastMethodType<Methods>[1]>) {\n        this.methods.push({\n            kind: 'filter',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType, Push<Methods,FilterFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily performs a side effect for each value using the provided callback (sync).\n     *\n     * Note: This is a pass-through, non-terminating operation. It can be used for observability (e.g., logging, debugging) within a pipeline. The iterator continues to yield values downstream.\n     */\n    forEach(cb: ForEachFunc<GetLastMethodType<Methods>[1]>) {\n        this.methods.push({\n            kind: 'forEach',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType, Push<Methods, ForEachFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily maps each value using the provided async callback.\n     */\n    mapAsync<S>(cb: MapAsyncFunc<GetLastMethodType<Methods>[1],S>) {\n        this.methods.push({\n            kind: 'mapAsync',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType, Push<Methods, MapAsyncFunc<GetLastMethodType<Methods>[1],S>>>\n    }\n\n    /**\n     * Lazily filters values using the provided async predicate.\n     */\n    filterAsync(cb: FilterAsyncFunc<GetLastMethodType<Methods>[1]>) {\n        this.methods.push({\n            kind: 'filterAsync',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType, Push<Methods, FilterAsyncFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily performs a side effect for each value using the provided async callback.\n     *\n     * Note: This is a pass-through, non-terminating operation. It can be used for observability (e.g., logging, debugging) within a pipeline. The iterator continues to yield values downstream.\n     */\n    forEachASync(cb: ForEachAsyncFunc<GetLastMethodType<Methods>[1]>) {\n        this.methods.push({\n            kind: 'forEachAsync',\n            fn: cb\n        });\n\n        return this as unknown as LazyAsyncIterator<IterType, Push<Methods, ForEachAsyncFunc<GetLastMethodType<Methods>[1],GetLastMethodType<Methods>[1]>>>;\n    }\n\n    /**\n     * Lazily reduces values to a single result using the provided reducer and initial value (sync).\n     */\n    reduce<S>(cb: ReduceFunc<GetLastMethodType<Methods>[1],S>, initVal: S) {\n        this.methods.push({\n            fn: cb,\n            kind: 'reduce',\n            initVal\n        })\n\n        const lazyIterator = this as unknown as LazyAsyncIterator<IterType, Push<Methods, ReduceFunc<GetLastMethodType<Methods>[1],S>>>\n\n        const reduceExec = new ReduceExecutor(lazyIterator);\n\n        return reduceExec;\n    }\n\n    /**\n     * Executes up to `concurrency` next() calls in parallel and returns all settled results.\n     *\n     * @throws Error If concurrency is not a positive integer.\n     */\n    private async _batchNext(concurrency: number): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        const promises: Promise<IteratorResult<GetLastMethodType<Methods>[1]>>[] = [];\n        for (let i = 0; i < concurrency; i++) {\n            promises.push(this.next());\n        }\n        return Promise.allSettled(promises);\n    }\n\n    /**\n     * Creates multiple independent async iterators (tees) from this iterator.\n     *\n     * @throws Error If count is not a positive integer.\n     */\n    tee(count: number) {\n        return createAsyncTeeIterators<GetLastMethodType<Methods>[1]>(this, count).map(v => LazyAsyncIterator.from(v))\n    }\n\n    /**\n     * Returns all values, throws on error, stops at first done. Supports concurrency.\n     *\n     * @throws Error If an error occurs in the pipeline.\n     */\n    async collect(concurrency: number = 1): Promise<GetLastMethodType<Methods>[1][]> {\n        const collected: GetLastMethodType<Methods>[1][] = [];\n        while (true) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled') {\n                    if (res.value.done) return collected;\n                    collected.push(res.value.value);\n                } else {\n                    throw res.reason;\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns all settled results (fulfilled and rejected), stops at first done. Supports concurrency.\n     */\n    async collectSettled(concurrency: number = 1): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        const collected: PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[] = [];\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if(res.status === 'rejected' || (res.status === 'fulfilled' && !res.value.done))\n                    collected.push(res);\n                if (res.status === 'fulfilled' && res.value.done) {\n                    done = true;\n                }\n            }\n        }\n        return collected;\n    }\n\n    /**\n     * Returns the first n values, throws on error. Supports concurrency.\n     *\n     * @throws Error If n is negative or not a number, or if an error occurs in the pipeline.\n     */\n    async take(n: number, concurrency: number = 1): Promise<GetLastMethodType<Methods>[1][]> {\n        if (typeof n !== 'number' || n < 0) throw new Error('take(n): n must be a non-negative number');\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let done = false;\n        while (!done && out.length < n) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled') {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    if(!res.value.done)\n                        out.push(res.value.value);\n                    if (out.length >= n) break;\n                } else {\n                    throw res.reason;\n                }\n            }\n        }\n        return out.slice(0, n);\n    }\n\n    /**\n     * Returns the first n settled results (fulfilled or rejected), stops at first done. Supports concurrency.\n     *\n     * @throws Error If n is negative or not a number.\n     */\n    async takeSettled(n: number, concurrency: number = 1): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        if (typeof n !== 'number' || n < 0) throw new Error('takeSettled(n): n must be a non-negative number');\n        const out: PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[] = [];\n        let done = false;\n        while (!done && out.length < n) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if(res.status === 'rejected' || (res.status === 'fulfilled' && !res.value.done))\n                    out.push(res);\n                if (res.status === 'fulfilled' && res.value.done) {\n                    done = true;\n                    break;\n                }\n                if (out.length >= n) break;\n            }\n        }\n        return out.slice(0, n);\n    }\n\n    /**\n     * Drops the first n values, returns the rest, throws on error. Supports concurrency.\n     *\n     * @throws Error If n is negative or not a number, or if an error occurs in the pipeline.\n     */\n    async drop(n: number, concurrency: number = 1): Promise<GetLastMethodType<Methods>[1][]> {\n        if (typeof n !== 'number' || n < 0) throw new Error('drop(n): n must be a non-negative number');\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let dropped = 0;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled') {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    if (dropped < n) {\n                        dropped++;\n                        continue;\n                    }\n                    if(!res.value.done)\n                        out.push(res.value.value);\n                } else {\n                    throw res.reason;\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Drops the first n values, returns all settled results for the rest. Supports concurrency.\n     *\n     * @throws Error If n is negative or not a number.\n     */\n    async dropSettled(n: number, concurrency: number = 1): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        if (typeof n !== 'number' || n < 0) throw new Error('dropSettled(n): n must be a non-negative number');\n        const out: PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[] = [];\n        let dropped = 0;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled' && dropped < n) {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    \n                    dropped++;\n                    continue;\n                }\n                if(res.status === 'rejected')\n                    out.push(res);\n                if (res.status === 'fulfilled') {\n                    if(res.value.done) {\n                        done = true;\n                        break;\n                    } else out.push(res)\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Returns values while predicate is true, throws on error. Supports concurrency.\n     *\n     * @throws Error If an error occurs in the pipeline.\n     */\n    async takeWhile(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean, concurrency: number = 1): Promise<GetLastMethodType<Methods>[1][]> {\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let idx = 0;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled') {\n                    if (res.value.done || !predicate(res.value.value, idx)) {\n                        done = true;\n                        break;\n                    }\n                    else\n                        out.push(res.value.value);\n                    idx++;\n                } else {\n                    throw res.reason;\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Returns all settled results while predicate is true, stops at first done. Supports concurrency.\n     */\n    async takeWhileSettled(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean, concurrency: number = 1): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        const out: PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[] = [];\n        let idx = 0;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if(res.status === 'rejected')\n                    out.push(res);\n                if (res.status === 'fulfilled') {\n                    if (res.value.done || !predicate(res.value.value, idx)) {\n                        done = true;\n                        break;\n                    }\n                    else {\n                        out.push(res)\n                    }\n                    idx++;\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Drops values while predicate is true, returns the rest, throws on error. Supports concurrency.\n     *\n     * @throws Error If an error occurs in the pipeline.\n     */\n    async dropWhile(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean, concurrency: number = 1): Promise<GetLastMethodType<Methods>[1][]> {\n        const out: GetLastMethodType<Methods>[1][] = [];\n        let idx = 0;\n        let dropping = true;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled') {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    if (dropping && predicate(res.value.value, idx)) {\n                        idx++;\n                        continue;\n                    }\n                    dropping = false;\n                    if(!res.value.done)\n                        out.push(res.value.value);\n                    idx++;\n                } else {\n                    throw res.reason;\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Drops values while predicate is true, returns all settled results for the rest. Supports concurrency.\n     */\n    async dropWhileSettled(predicate: (x: GetLastMethodType<Methods>[1], idx: number) => boolean, concurrency: number = 1): Promise<PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[]> {\n        const out: PromiseSettledResult<IteratorResult<GetLastMethodType<Methods>[1], any>>[] = [];\n        let idx = 0;\n        let dropping = true;\n        let done = false;\n        while (!done) {\n            const results = await this._batchNext(concurrency);\n            for (const res of results) {\n                if (res.status === 'fulfilled' && dropping && predicate(res.value.value, idx)) {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    idx++;\n                    continue;\n                }\n                if(res.status === 'rejected')\n                    out.push(res);\n                if (res.status === 'fulfilled') {\n                    if (res.value.done) {\n                        done = true;\n                        break;\n                    }\n                    if (dropping && predicate(res.value.value, idx)) {\n                        idx++;\n                        continue;\n                    }\n                    if(!res.value.done)\n                        out.push(res)\n                    dropping = false;\n                    idx++;\n                }\n            }\n        }\n        return out;\n    }\n}\n\ntype ExtractLazyIteratorMethods<T extends unknown> =\n    T extends LazyAsyncIterator<infer _, infer Q> \n    ? Q\n    : never;\n\n\n/**\n * Executes a reduce operation on a LazyAsyncIterator chain.\n */\nclass ReduceExecutor<R extends any, S extends AsyncIterMethods<any,any>, T extends LazyAsyncIterator<R, S[]>> {\n    private lazyIterator: T;\n\n    constructor(lazyIterator: T) {\n        this.lazyIterator = lazyIterator;\n    }\n\n    /**\n     * Executes the reduce operation and returns the result.\n     */\n    async execute() {\n        const reduceMethod = this.lazyIterator.methods.at(-1)!;\n        this.lazyIterator.methods.slice(0,-1);\n        const array = await this.lazyIterator.collect();\n        //@ts-expect-error\n        const result = array.reduce(reduceMethod.fn as unknown as ReduceFunc<GetLastMethodType<ExtractLazyIteratorMethods<T>>[0],GetLastMethodType<ExtractLazyIteratorMethods<T>>[1]>, reduceMethod.initVal);\n        return result as unknown as GetLastMethodType<ExtractLazyIteratorMethods<T>>[1]\n    }\n}\n\n\n// const it = await new LazyAsyncIterator([1,2,3,4][Symbol.iterator]()).mapAsync((x, i) => Promise.resolve({ num: x })).collectSettled() //reduce((acc, curr) => ({sum: acc.sum + curr.num}), {sum: 0}).execute()\n\n\n", "import { createTeeIterators, teeConsumers, TeeConsumer } from './tee';\nimport { LazyIterator } from './lazy-iterator'\nimport { LazyAsyncIterator } from './lazy-async-iterator'\n\n\n\nArray.tee = createTeeIterators;\n\nArray.prototype.tee = teeConsumers;\n\n\n// TypeScript module augmentation for Array.tee\ndeclare global {\n  interface Array<T> {\n    /**\n     * Disclaimer: This method is not a part of the ECMAScript Standard. It is attached to `Array` by `tee-js`.\n     * \n     * Applies multiple consumer operations (map, filter, reduce, forEach) in parallel to an array, using independent iterators for each consumer.\n     * Each consumer receives elements and their index, and results are returned in an array matching the order of consumers.\n     * Supports runtime type checking for consumer configuration and robust error handling.\n     * @example\n     * const arr = [1,2,3];\n     * const results = arr.tee(\n     *   { kind: 'map', fn: (x, i) => x * 2 },\n     *   { kind: 'filter', fn: (x, i) => x % 2 === 1 },\n     *   { kind: 'reduce', fn: (acc, x, i) => acc + x, initVal: 0 },\n     *   { kind: 'forEach', fn: (x, i) => console.log(x) }\n     * );\n     * // results: [[2,4,6], [1,3], 6, undefined]\n     */\n    tee<S>(...consumers: readonly TeeConsumer<T,S>[]): any[];\n  }\n  interface ArrayConstructor {\n    /**\n     * Disclaimer: This method is not a part of the ECMAScript Standard. It is attached to `Array` by `tee-js`.\n     * \n     * Creates multiple independent lazy iterators from a single iterable source, allowing parallel consumption without re-traversing the source.\n     * Each returned iterator is will yield the same sequence of values as the original iterable, but can be consumed at different rates.\n     * Each returned iterator is lazy and only consumes values from the source iterable as they are requested.\n     *\n     * @template T - The type of elements in the source iterable.\n     * @param {Iterable<T>} sourceIterable - The iterable to split into multiple iterators.\n     * @param {number} count - The number of independent iterators to create.\n     * @returns {IterableIterator<T>[]} An array of independent iterators over the source iterable.\n     * @throws {Error} If incorrect arguments are provided or the source is not iterable.\n     *\n     * @example\n     * const arr = [1, 2, 3, 4];\n     * const [it1, it2] = Array.tee(arr, 2);\n     * console.log(it1.next().value); // 1\n     * console.log(it2.next().value); // 1\n     * console.log(it1.next().value); // 2\n     * console.log(it2.next().value); // 2\n     */\n    tee<T>(sourceIterable: Iterable<T>, count: number): IterableIterator<T>[];\n  }\n}\n\nexport {\n    LazyIterator,\n    LazyAsyncIterator\n};"],
  "mappings": ";AAmBO,SAAS,mBAAsB,gBAA6B,OAAsC;AACrG,MAAG,UAAU,WAAW;AAAG,UAAM,IAAI,MAAM,sCAAsC,UAAU,MAAM,EAAE;AACnG,MAAG,CAAC,eAAe,OAAO,QAAQ;AAAG,UAAM,IAAI,MAAM,mCAAmC;AACxF,MAAG,EAAE,OAAO,UAAU;AAAW,UAAM,IAAI,MAAM,iCAAiC;AAGlF,UAAQ,KAAK,MAAM,KAAK;AAExB,QAAM,iBAAiB,eAAe,OAAO,QAAQ,EAAE;AACvD,QAAM,yBAAmC,MAAM,KAAK,EAAE,KAAK,CAAC;AAC5D,QAAM,eAAoB,CAAC;AAE3B,MAAI,kBAAkB;AACtB,MAAI,cAA4B;AAKhC,WAAS,uBAAuB;AAC5B,QAAG;AAAiB,aAAO,EAAE,OAAO,QAAW,MAAM,KAAI;AACzD,QAAG;AAAa,YAAM;AAEtB,QAAI;AACA,YAAM,SAAS,eAAe,KAAK;AACnC,UAAG,OAAO;AAAM,0BAAkB;AAElC,aAAO;AAAA,IACX,SAAQ,GAAG;AACP,oBAAc;AACd,YAAM;AAAA,IACV;AAAA,EACJ;AAKA,WAAS,sBAAsB;AAC3B,UAAM,wBAAwB,KAAK,IAAI,GAAG,sBAAsB;AAChE,UAAM,uBAAuB;AAC7B,iBAAa,OAAO,GAAG,oBAAoB;AAC3C,aAAQ,IAAI,GAAG,IAAI,OAAO,KAAK;AAC3B,6BAAuB,CAAC,KAAK;AAAA,IACjC;AAAA,EACJ;AAKA,WAAS,mBAAmB,OAAoC;AAC5D,QAAI,OAAO;AACX,WAAO;AAAA,MACH,CAAC,OAAO,QAAQ,IAAI;AAChB,eAAO;AAAA,MACX;AAAA,MACA,OAA0B;AACtB,YAAG;AAAM,iBAAO,EAAE,OAAO,QAAW,MAAM,KAAI;AAO9C,YAAG,uBAAuB,KAAK,IAAI,aAAa,QAAQ;AACpD,gBAAM,QAAQ,aAAa,uBAAuB,KAAK,CAAC;AACxD,iCAAuB,KAAK;AAC5B,8BAAoB;AACpB,iBAAO,EAAE,OAAO,MAAM,MAAM;AAAA,QAChC;AAEA,cAAM,SAAS,qBAAqB;AAEpC,YAAG,OAAO,MAAM;AACZ,iBAAO;AACP,iBAAO,EAAC,MAAM,MAAM,OAAO,OAAS;AAAA,QACxC;AAGA,qBAAa,KAAK,OAAO,KAAM;AAE/B,+BAAuB,KAAK;AAC5B,4BAAoB;AAOpB,eAAO,EAAE,OAAO,OAAO,OAAQ,MAAM,MAAM;AAAA,MAE/C;AAAA,MACA,OAAO,OAAO;AACV,YAAG,CAAC,MAAM;AACN,iBAAO;AAAA,QACX;AACA,eAAO,EAAE,OAAO,KAAI;AAAA,MACxB;AAAA,MACA,MAAM,GAAG;AACL,YAAG,CAAC,MAAM;AACN,iBAAO;AAAA,QACX;AACA,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,MAAM,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,GAAG,QAAQ,mBAAmB,GAAG,CAAC;AACvE;AAIA,SAAS,qBAAqB,OAAe;AACzC,QAAM,yBAAmC,MAAM,KAAK,EAAE,KAAK,CAAC;AAC5D,QAAM,eAAsB,CAAC;AAC7B,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,sBAAsB;AAClB,YAAM,wBAAwB,KAAK,IAAI,GAAG,sBAAsB;AAChE,YAAM,uBAAuB;AAC7B,mBAAa,OAAO,GAAG,oBAAoB;AAC3C,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,+BAAuB,CAAC,KAAK;AAAA,MACjC;AAAA,IACJ;AAAA,EACJ;AACJ;AAWO,SAAS,wBAA2B,qBAA0D,OAA2C;AAC5I,MAAI,UAAU,WAAW;AAAG,UAAM,IAAI,MAAM,sCAAsC,UAAU,MAAM,EAAE;AACpG,MAAI,CAAC,uBAAwB,OAAO,wBAAwB;AAAW,UAAM,IAAI,MAAM,2DAA2D;AAClJ,MAAI,EAAE,OAAO,UAAU;AAAW,UAAM,IAAI,MAAM,iCAAiC;AACnF,UAAQ,KAAK,MAAM,KAAK;AAGxB,MAAI;AACJ,MAAI,OAAQ,oBAA4B,OAAO,aAAa,MAAM,YAAY;AAC1E,qBAAkB,oBAAyC,OAAO,aAAa,EAAE;AAAA,EACrF,WAAW,OAAQ,oBAA4B,SAAS,YAAY;AAChE,qBAAiB;AAAA,EACrB,OAAO;AACH,UAAM,IAAI,MAAM,gDAAgD;AAAA,EACpE;AAEA,QAAM,EAAE,wBAAwB,cAAc,oBAAoB,IAAI,qBAAqB,KAAK;AAChG,MAAI,kBAAkB;AACtB,MAAI,cAA4B;AAEhC,iBAAe,4BAA4B;AACvC,QAAI;AAAiB,aAAO,EAAE,OAAO,QAAW,MAAM,KAAK;AAC3D,QAAI;AAAa,YAAM;AACvB,QAAI;AACA,YAAM,SAAS,MAAM,eAAe,KAAK;AACzC,UAAI,OAAO;AAAM,0BAAkB;AACnC,aAAO;AAAA,IACX,SAAS,GAAG;AACR,oBAAc;AACd,YAAM;AAAA,IACV;AAAA,EACJ;AAEA,WAAS,wBAAwB,OAAyC;AACtE,QAAI,OAAO;AACX,WAAO;AAAA,MACH,CAAC,OAAO,aAAa,IAAI;AACrB,eAAO;AAAA,MACX;AAAA,MACA,MAAM,OAAmC;AACrC,YAAI;AAAM,iBAAO,EAAE,OAAO,QAAW,MAAM,KAAK;AAChD,YAAI,uBAAuB,KAAK,IAAI,aAAa,QAAQ;AACrD,gBAAM,QAAQ,aAAa,uBAAuB,KAAK,CAAC;AACxD,iCAAuB,KAAK;AAC5B,8BAAoB;AACpB,iBAAO,EAAE,OAAO,MAAM,MAAM;AAAA,QAChC;AACA,cAAM,SAAS,MAAM,0BAA0B;AAC/C,YAAI,OAAO,MAAM;AACb,iBAAO;AACP,iBAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,QAC1C;AACA,qBAAa,KAAK,OAAO,KAAM;AAC/B,+BAAuB,KAAK;AAC5B,4BAAoB;AACpB,eAAO,EAAE,OAAO,OAAO,OAAQ,MAAM,MAAM;AAAA,MAC/C;AAAA,MACA,MAAM,OAAO,OAAO;AAChB,YAAI,CAAC,MAAM;AACP,iBAAO;AAAA,QACX;AACA,eAAO,EAAE,OAAO,KAAK;AAAA,MACzB;AAAA,MACA,MAAM,MAAM,GAAG;AACX,YAAI,CAAC,MAAM;AACP,iBAAO;AAAA,QACX;AACA,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,MAAM,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,GAAG,QAAQ,wBAAwB,GAAG,CAAC;AAC5E;AA+DO,SAAS,gBAAqC,WAA+B;AAEhF,MAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACtB,UAAM,IAAI,UAAU,yCAAyC;AAAA,EACjE;AACA,MAAI,CAAC,UAAU,QAAQ;AACnB,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAC5D;AAEA,aAAW,YAAY,WAAW;AAC9B,QAAI,OAAO,aAAa,YAAY,aAAa,MAAM;AACnD,YAAM,IAAI,UAAU,iCAAiC;AAAA,IACzD;AACA,QAAI,EAAE,UAAU,aAAa,OAAO,SAAS,SAAS,UAAU;AAC5D,YAAM,IAAI,UAAU,gDAAgD;AAAA,IACxE;AACA,QAAI,OAAO,SAAS,OAAO,YAAY;AACnC,YAAM,IAAI,UAAU,gDAAgD;AAAA,IACxE;AACA,QAAI,SAAS,SAAS,YAAY,EAAE,aAAa,WAAW;AAAA,IAE5D;AAAA,EACJ;AAGA,QAAM,cAAc,MAAM,KAAK,SAAS;AACxC,QAAM,aAAoB,MAAM,YAAY,MAAM,EAAE,KAAK,CAAC;AAC1D,QAAM,YAAY,mBAAmB,MAAM,YAAY,MAAM;AAG7D,WAAS,cAAc,GAAG,cAAc,YAAY,QAAQ,eAAe;AACvE,UAAM,KAAK,YAAY,WAAW;AAClC,UAAM,YAAmB,CAAC;AAC1B,QAAI,eAAoB,GAAG,SAAS,WAAW,GAAG,UAAU;AAC5D,QAAI,eAAoB,CAAC;AACzB,QAAI,aAAa;AAEjB,eAAU,QAAQ,UAAU,WAAW,GAAG;AACtC,cAAO,GAAG,MAAM;AAAA,QACZ,KAAK;AACD,aAAG,GAAG,MAAM,UAAU;AACtB;AAAA,QACJ,KAAK;AACD;AACI,kBAAM,MAAM,GAAG,GAAG,MAAM,UAAU;AAClC,sBAAU,KAAK,GAAG;AAAA,UACtB;AACA;AAAA,QACJ,KAAK;AACD;AACI,gBAAI,eAAe,KAAK,iBAAiB,QAAW;AAChD,6BAAe;AAAA,YACnB,OAAO;AACH,6BAAe,GAAG,GAAG,cAAc,MAAM,UAAU;AAAA,YACvD;AAAA,UACJ;AACA;AAAA,QACJ,KAAK;AACD;AACI,gBAAI,GAAG,GAAG,MAAM,UAAU;AACtB,2BAAa,KAAK,IAAI;AAAA,UAC9B;AACA;AAAA,QACJ;AACI,gBAAM,IAAI,MAAM,0BAA0B,OAAQ,GAAW,IAAI,CAAC,EAAE;AAAA,MAC5E;AACA;AAAA,IACJ;AAEA,YAAO,GAAG,MAAM;AAAA,MACZ,KAAK;AACD,mBAAW,WAAW,IAAI;AAC1B;AAAA,MACJ,KAAK;AACD,mBAAW,WAAW,IAAI;AAC1B;AAAA,MACJ,KAAK;AACD,mBAAW,WAAW,IAAI;AAC1B;AAAA,MACJ,KAAK;AACD,mBAAW,WAAW,IAAI;AAC1B;AAAA,IACR;AAAA,EACJ;AAEA,SAAO;AACX;;;AC9TO,IAAM,eAAN,MAAM,cAAgI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBzI,OAAO,KAAQ,MAAiC;AAC5C,QAAG,SAAS,UAAa,SAAS;AAAM,YAAM,IAAI,MAAM,uDAAuD;AAC/G,QAAG,UAAU,QAAQ,OAAO,KAAK,SAAS,YAAY;AAClD,aAAO,IAAI,cAAgB,IAAI;AAAA,IACnC;AAEA,QAAI,OAAO,SAAS,YAAY,OAAO,YAAY,MAAM;AACrD,YAAM,WAAY,KAAqB,OAAO,QAAQ,EAAE;AACxD,aAAO,IAAI,cAAgB,QAAQ;AAAA,IACvC;AAEA,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,UAA8B;AACtC,SAAK,WAAW;AAChB,SAAK,WAAW,CAAC;AACjB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEQ,mBAAsB,QAI3B,KAAQ,OAAe;AACtB,YAAO,OAAO,MAAM;AAAA,MAChB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,WACD;AACI,cAAM,KAAK,OAAO;AAClB,eAAO,GAAG,KAAK,KAAK;AAAA,MACxB;AAAA,MACJ,KAAK,UACD;AACI,cAAM,KAAK,OAAO;AAClB,eAAO,GAAG,CAAC,GAAG,KAAK,KAAK;AAAA,MAC5B;AAAA,MACJ;AACI,eAAO,CAAC;AAAA,IAChB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAgE;AAE5D,QAAG,KAAK;AAAW,aAAO,EAAE,MAAM,MAAM,OAAO,OAAS;AAExD,WAAM,MAAM;AACR,YAAM,UAAU,KAAK,SAAS,KAAK;AAEnC,UAAG,QAAQ,MAAM;AACb,aAAK,YAAY;AAChB,eAAO,EAAE,MAAM,MAAM,OAAO,OAAS;AAAA,MAC1C;AAEA,UAAG,KAAK,SAAS,WAAW;AAAG,eAAO,EAAE,OAAO,QAAQ,OAAO,MAAM,MAAK;AAGzE,UAAI,aAAa;AACjB,UAAI,IAAI,QAAQ;AAEhB,eAAQ,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC1C,YAAI,SAAS,KAAK,mBAAmB,KAAK,SAAS,CAAC,GAAG,GAAG,KAAK,KAAK;AAIpE,YAAG,KAAK,SAAS,CAAC,EAAE,SAAS;AACzB,cAAI;AACR,YAAG,KAAK,SAAS,CAAC,EAAE,SAAS,YAAY,WAAW,OAAO;AACvD,uBAAa;AACb;AAAA,QACJ;AAAA,MACJ;AAGA,WAAK;AAEL,UAAG;AAAY;AAEf,aAAO,EAAE,MAAM,OAAO,OAAO,EAAC;AAAA,IAClC;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,OAAY;AACf,QAAG,CAAC,KAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACrB;AAEA,WAAO,EAAE,OAAO,MAAM,KAAK,UAAU;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,GAAQ;AACV,QAAG,CAAC,KAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACrB;AAEA,WAAO,EAAE,MAAM,KAAK,WAAW,OAAO,OAAS;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,CAAC,OAAO,QAAQ,IAAI;AAChB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,IAAO,IAA8C;AACjD,SAAK,SAAS,KAAK;AAAA,MACf,IAAI;AAAA,MACJ,MAAM;AAAA,IACV,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,IAA+C;AAClD,SAAK,SAAS,KAAK;AAAA,MACf,IAAI;AAAA,MACJ,MAAM;AAAA,IACV,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,IAAgD;AACpD,SAAK,SAAS,KAAK;AAAA,MACf,IAAI;AAAA,MACJ,MAAM;AAAA,IACV,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAU,IAAiD,SAAY;AACnE,SAAK,SAAS,KAAK;AAAA,MACf,IAAI;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAED,UAAM,eAAe;AAErB,UAAM,aAAa,IAAI,eAAe,YAAY;AAElD,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,UAA2C;AACvC,WAAO,KAAK,QAAQ;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAe;AACf,WAAO,mBAAkD,MAAM,KAAK,EAAE,IAAI,OAAK,cAAa,KAAK,CAAC,CAAC;AAAA,EACvG;AAAA;AAAA;AAAA;AAAA,EAKA,UAA2C;AACvC,UAAM,MAAoC,CAAC;AAC3C,eAAU,QAAQ,MAAM;AACpB,UAAI,KAAK,IAAI;AAAA,IACjB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,GAA4C;AAC7C,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,0CAA0C;AAC9F,UAAM,MAAuC,CAAC;AAC9C,QAAI,QAAQ;AACZ,eAAW,QAAQ,MAAM;AACrB,UAAI,WAAW;AAAG;AAClB,UAAI,KAAK,IAAI;AAAA,IACjB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,GAA4C;AAC7C,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,0CAA0C;AAC9F,UAAM,MAAuC,CAAC;AAC9C,QAAI,QAAQ;AACZ,eAAW,QAAQ,MAAM;AACrB,UAAI,UAAU;AAAG;AACjB,UAAI,KAAK,IAAI;AAAA,IACjB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,WAAwG;AAC9G,UAAM,MAAuC,CAAC;AAC9C,QAAI,MAAM;AACV,eAAW,QAAQ,MAAM;AACrB,UAAI,CAAC,UAAU,MAAM,GAAG;AAAG;AAC3B,UAAI,KAAK,IAAI;AACb;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,WAAwG;AAC9G,UAAM,MAAuC,CAAC;AAC9C,QAAI,MAAM;AACV,QAAI,WAAW;AACf,eAAW,QAAQ,MAAM;AACrB,UAAI,YAAY,UAAU,MAAM,GAAG,GAAG;AAClC;AACA;AAAA,MACJ;AACA,iBAAW;AACX,UAAI,KAAK,IAAI;AACb;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AAWA,IAAM,iBAAN,MAAwG;AAAA,EAGpG,YAAY,cAAiB;AACzB,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACN,UAAM,eAAe,KAAK,aAAa,SAAS,GAAG,EAAE;AACrD,SAAK,aAAa,SAAS,MAAM,GAAE,EAAE;AACrC,UAAM,QAAQ,KAAK,aAAa,QAAQ;AACxC,UAAM,SAAS,MAAM,OAAO,aAAa,IAAsI,aAAa,OAAO;AACnM,WAAO;AAAA,EACX;AACJ;;;ACjTO,IAAM,oBAAN,MAAM,mBAAqK;AAAA;AAAA;AAAA;AAAA,EAY9K,YAAY,UAAwD;AAChE,SAAK,WAAW;AAChB,SAAK,UAAU,CAAC;AAChB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,KAAQ,OAA8F;AACzG,QAAI,UAAU,UAAa,UAAU,MAAM;AACvC,YAAM,IAAI,MAAM,4DAA4D;AAAA,IAChF;AAEA,QAAI,OAAO,UAAU,YAAY,UAAU,SAAS,OAAO,MAAM,SAAS,cAAe,OAAO,iBAAiB,OAAQ;AACrH,aAAO,IAAI,mBAAqB,KAAyB;AAAA,IAC7D;AAEA,QAAI,OAAO,UAAU,YAAY,UAAU,SAAS,OAAO,MAAM,SAAS,cAAe,OAAO,YAAY,OAAQ;AAChH,aAAO,IAAI,mBAAqB,KAAoB;AAAA,IACxD;AAEA,QAAI,OAAO,UAAU,YAAY,OAAO,iBAAiB,OAAO;AAC5D,YAAM,WAAY,MAA2B,OAAO,aAAa,EAAE;AACnE,aAAO,IAAI,mBAAqB,QAAQ;AAAA,IAC5C;AAEA,QAAI,OAAO,UAAU,YAAY,OAAO,YAAY,OAAO;AACvD,YAAM,WAAY,MAAsB,OAAO,QAAQ,EAAE;AACzD,aAAO,IAAI,mBAAqB,QAAQ;AAAA,IAC5C;AACA,UAAM,IAAI,MAAM,4EAA4E;AAAA,EAChG;AAAA,EAEA,MAAc,iBAAiB;AAC3B,QAAG,OAAO,YAAY,KAAK,YAAY,OAAO,iBAAiB,KAAK;AAChE,aAAO,KAAK,SAAS,KAAK;AAC9B,WAAO,EAAE,MAAM,MAAM,OAAO,OAAS;AAAA,EACzC;AAAA,EAEA,MAAc,qBAAwB,QAA4C,OAAU,OAAe;AACvG,WAAO,OAAO,GAAG,OAAO,KAAK;AAAA,EACjC;AAAA,EAEQ,oBAAuB,QAAsB,OAAU,OAAe,SAAe;AACzF,WAAO,OAAO,GAAG,SAAS,OAAO,KAAK;AAAA,EAC1C;AAAA,EAEA,CAAC,OAAO,aAAa,IAAI;AACrB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAA+D;AACjE,QAAG,KAAK;AAAW,aAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAEzD,WAAM,MAAM;AACR,YAAM,aAAa,MAAM,KAAK,eAAe;AAE7C,UAAG,WAAW,MAAM;AAChB,aAAK,YAAY;AACjB,eAAO,EAAE,MAAM,MAAM,OAAO,OAAU;AAAA,MAC1C;AAEA,UAAG,KAAK,QAAQ,WAAW;AAAG,eAAO,EAAE,MAAM,OAAO,OAAO,WAAW,MAAM;AAE5E,UAAI,WAAW,WAAW;AAC1B,UAAI,aAAa;AAEjB,iBAAU,UAAU,KAAK,SAAS;AAC9B,YAAI;AACJ,YAAG,OAAO,SAAS,UAAU;AACzB,mBAAS,MAAM,KAAK,qBAAqB,QAAQ,UAAU,KAAK,KAAK;AAAA,QACzE,OACK;AACD,eAAK,oBAAoB,QAAQ,UAAU,KAAK,OAAO,OAAO,OAAO;AAAA,QACzE;AAEA,YAAG,OAAO,SAAS,SAAS,OAAO,SAAS;AACxC,qBAAW;AAEf,aAAI,OAAO,SAAS,YAAY,OAAO,SAAS,kBAAkB,CAAC,QAAQ;AACvE,uBAAa;AACb;AAAA,QACJ;AAAA,MACJ;AAEA,WAAK;AAEL,UAAG;AAAY;AAEf,aAAO,EAAE,MAAM,OAAO,OAAO,SAAS;AAAA,IAC1C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,OAAY;AACrB,QAAG,CAAC,KAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACrB;AAEA,WAAO,EAAE,OAAO,MAAM,KAAK,UAAU;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,GAAQ;AAChB,QAAG,CAAC,KAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACrB;AAEA,WAAO,EAAE,MAAM,KAAK,WAAW,OAAO,OAAS;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAO,IAA8C;AACjD,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,IAA+C;AAClD,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,IAAgD;AACpD,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,SAAY,IAAmD;AAC3D,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,IAAoD;AAC5D,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,IAAqD;AAC9D,SAAK,QAAQ,KAAK;AAAA,MACd,MAAM;AAAA,MACN,IAAI;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAU,IAAiD,SAAY;AACnE,SAAK,QAAQ,KAAK;AAAA,MACd,IAAI;AAAA,MACJ,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAED,UAAM,eAAe;AAErB,UAAM,aAAa,IAAIA,gBAAe,YAAY;AAElD,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,WAAW,aAA0G;AAC/H,UAAM,WAAqE,CAAC;AAC5E,aAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,eAAS,KAAK,KAAK,KAAK,CAAC;AAAA,IAC7B;AACA,WAAO,QAAQ,WAAW,QAAQ;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAe;AACf,WAAO,wBAAuD,MAAM,KAAK,EAAE,IAAI,OAAK,mBAAkB,KAAK,CAAC,CAAC;AAAA,EACjH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,cAAsB,GAA6C;AAC7E,UAAM,YAA6C,CAAC;AACpD,WAAO,MAAM;AACT,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM;AAAM,mBAAO;AAC3B,oBAAU,KAAK,IAAI,MAAM,KAAK;AAAA,QAClC,OAAO;AACH,gBAAM,IAAI;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,cAAsB,GAAwF;AAC/H,UAAM,YAAwF,CAAC;AAC/F,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAG,IAAI,WAAW,cAAe,IAAI,WAAW,eAAe,CAAC,IAAI,MAAM;AACtE,oBAAU,KAAK,GAAG;AACtB,YAAI,IAAI,WAAW,eAAe,IAAI,MAAM,MAAM;AAC9C,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,GAAW,cAAsB,GAA6C;AACrF,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,0CAA0C;AAC9F,UAAM,MAAuC,CAAC;AAC9C,QAAI,OAAO;AACX,WAAO,CAAC,QAAQ,IAAI,SAAS,GAAG;AAC5B,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AACA,cAAG,CAAC,IAAI,MAAM;AACV,gBAAI,KAAK,IAAI,MAAM,KAAK;AAC5B,cAAI,IAAI,UAAU;AAAG;AAAA,QACzB,OAAO;AACH,gBAAM,IAAI;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,IAAI,MAAM,GAAG,CAAC;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,GAAW,cAAsB,GAAwF;AACvI,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,iDAAiD;AACrG,UAAM,MAAkF,CAAC;AACzF,QAAI,OAAO;AACX,WAAO,CAAC,QAAQ,IAAI,SAAS,GAAG;AAC5B,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAG,IAAI,WAAW,cAAe,IAAI,WAAW,eAAe,CAAC,IAAI,MAAM;AACtE,cAAI,KAAK,GAAG;AAChB,YAAI,IAAI,WAAW,eAAe,IAAI,MAAM,MAAM;AAC9C,iBAAO;AACP;AAAA,QACJ;AACA,YAAI,IAAI,UAAU;AAAG;AAAA,MACzB;AAAA,IACJ;AACA,WAAO,IAAI,MAAM,GAAG,CAAC;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,GAAW,cAAsB,GAA6C;AACrF,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,0CAA0C;AAC9F,UAAM,MAAuC,CAAC;AAC9C,QAAI,UAAU;AACd,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AACA,cAAI,UAAU,GAAG;AACb;AACA;AAAA,UACJ;AACA,cAAG,CAAC,IAAI,MAAM;AACV,gBAAI,KAAK,IAAI,MAAM,KAAK;AAAA,QAChC,OAAO;AACH,gBAAM,IAAI;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,GAAW,cAAsB,GAAwF;AACvI,QAAI,OAAO,MAAM,YAAY,IAAI;AAAG,YAAM,IAAI,MAAM,iDAAiD;AACrG,UAAM,MAAkF,CAAC;AACzF,QAAI,UAAU;AACd,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,eAAe,UAAU,GAAG;AAC3C,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AAEA;AACA;AAAA,QACJ;AACA,YAAG,IAAI,WAAW;AACd,cAAI,KAAK,GAAG;AAChB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAG,IAAI,MAAM,MAAM;AACf,mBAAO;AACP;AAAA,UACJ;AAAO,gBAAI,KAAK,GAAG;AAAA,QACvB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,WAAuE,cAAsB,GAA6C;AACtJ,UAAM,MAAuC,CAAC;AAC9C,QAAI,MAAM;AACV,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,QAAQ,CAAC,UAAU,IAAI,MAAM,OAAO,GAAG,GAAG;AACpD,mBAAO;AACP;AAAA,UACJ;AAEI,gBAAI,KAAK,IAAI,MAAM,KAAK;AAC5B;AAAA,QACJ,OAAO;AACH,gBAAM,IAAI;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAuE,cAAsB,GAAwF;AACxM,UAAM,MAAkF,CAAC;AACzF,QAAI,MAAM;AACV,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAG,IAAI,WAAW;AACd,cAAI,KAAK,GAAG;AAChB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,QAAQ,CAAC,UAAU,IAAI,MAAM,OAAO,GAAG,GAAG;AACpD,mBAAO;AACP;AAAA,UACJ,OACK;AACD,gBAAI,KAAK,GAAG;AAAA,UAChB;AACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,WAAuE,cAAsB,GAA6C;AACtJ,UAAM,MAAuC,CAAC;AAC9C,QAAI,MAAM;AACV,QAAI,WAAW;AACf,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AACA,cAAI,YAAY,UAAU,IAAI,MAAM,OAAO,GAAG,GAAG;AAC7C;AACA;AAAA,UACJ;AACA,qBAAW;AACX,cAAG,CAAC,IAAI,MAAM;AACV,gBAAI,KAAK,IAAI,MAAM,KAAK;AAC5B;AAAA,QACJ,OAAO;AACH,gBAAM,IAAI;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAuE,cAAsB,GAAwF;AACxM,UAAM,MAAkF,CAAC;AACzF,QAAI,MAAM;AACV,QAAI,WAAW;AACf,QAAI,OAAO;AACX,WAAO,CAAC,MAAM;AACV,YAAM,UAAU,MAAM,KAAK,WAAW,WAAW;AACjD,iBAAW,OAAO,SAAS;AACvB,YAAI,IAAI,WAAW,eAAe,YAAY,UAAU,IAAI,MAAM,OAAO,GAAG,GAAG;AAC3E,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AACA;AACA;AAAA,QACJ;AACA,YAAG,IAAI,WAAW;AACd,cAAI,KAAK,GAAG;AAChB,YAAI,IAAI,WAAW,aAAa;AAC5B,cAAI,IAAI,MAAM,MAAM;AAChB,mBAAO;AACP;AAAA,UACJ;AACA,cAAI,YAAY,UAAU,IAAI,MAAM,OAAO,GAAG,GAAG;AAC7C;AACA;AAAA,UACJ;AACA,cAAG,CAAC,IAAI,MAAM;AACV,gBAAI,KAAK,GAAG;AAChB,qBAAW;AACX;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AAWA,IAAMA,kBAAN,MAA8G;AAAA,EAG1G,YAAY,cAAiB;AACzB,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU;AACZ,UAAM,eAAe,KAAK,aAAa,QAAQ,GAAG,EAAE;AACpD,SAAK,aAAa,QAAQ,MAAM,GAAE,EAAE;AACpC,UAAM,QAAQ,MAAM,KAAK,aAAa,QAAQ;AAE9C,UAAM,SAAS,MAAM,OAAO,aAAa,IAAsI,aAAa,OAAO;AACnM,WAAO;AAAA,EACX;AACJ;;;ACrnBA,MAAM,MAAM;AAEZ,MAAM,UAAU,MAAM;",
  "names": ["ReduceExecutor"]
}
