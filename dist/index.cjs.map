{
  "version": 3,
  "sources": ["../src/index.ts", "../src/tee.ts", "../src/lazy-iterator.ts"],
  "sourcesContent": ["import {createTeeIterators, teeConsumers, TeeConsumer} from './tee';\nimport { LazyIterator } from './lazy-iterator'\n\n\n\nArray.tee = createTeeIterators;\n\nArray.prototype.tee = teeConsumers;\n\n\n// TypeScript module augmentation for Array.tee\ndeclare global {\n  interface Array<T> {\n    /**\n     * Disclaimer: This method is not a part of the ECMAScript Standard. It is attached to `Array` by `tee-js`.\n     * \n     * Applies multiple consumer operations (map, filter, reduce, forEach) in parallel to an array, using independent iterators for each consumer.\n     * Each consumer receives elements and their index, and results are returned in an array matching the order of consumers.\n     * Supports runtime type checking for consumer configuration and robust error handling.\n     * @example\n     * const arr = [1,2,3];\n     * const results = arr.tee(\n     *   { kind: 'map', fn: (x, i) => x * 2 },\n     *   { kind: 'filter', fn: (x, i) => x % 2 === 1 },\n     *   { kind: 'reduce', fn: (acc, x, i) => acc + x, initVal: 0 },\n     *   { kind: 'forEach', fn: (x, i) => console.log(x) }\n     * );\n     * // results: [[2,4,6], [1,3], 6, undefined]\n     */\n    tee<S>(...consumers: readonly TeeConsumer<T,S>[]): any[];\n  }\n  interface ArrayConstructor {\n    /**\n     * Disclaimer: This method is not a part of the ECMAScript Standard. It is attached to `Array` by `tee-js`.\n     * \n     * Creates multiple independent lazy iterators from a single iterable source, allowing parallel consumption without re-traversing the source.\n     * Each returned iterator is will yield the same sequence of values as the original iterable, but can be consumed at different rates.\n     * Each returned iterator is lazy and only consumes values from the source iterable as they are requested.\n     *\n     * @template T - The type of elements in the source iterable.\n     * @param {Iterable<T>} sourceIterable - The iterable to split into multiple iterators.\n     * @param {number} count - The number of independent iterators to create.\n     * @returns {IterableIterator<T>[]} An array of independent iterators over the source iterable.\n     * @throws {Error} If incorrect arguments are provided or the source is not iterable.\n     *\n     * @example\n     * const arr = [1, 2, 3, 4];\n     * const [it1, it2] = Array.tee(arr, 2);\n     * console.log(it1.next().value); // 1\n     * console.log(it2.next().value); // 1\n     * console.log(it1.next().value); // 2\n     * console.log(it2.next().value); // 2\n     */\n    tee<T>(sourceIterable: Iterable<T>, count: number): IterableIterator<T>[];\n  }\n}\n\nexport {\n    LazyIterator\n};", "/**\n * Creates multiple independent lazy iterators from a single iterable source, allowing parallel consumption without re-traversing the source.\n * Each returned iterator is will yield the same sequence of values as the original iterable, but can be consumed at different rates.\n * Each returned iterator is lazy and only consumes values from the source iterable as they are requested.\n *\n * @template T - The type of elements in the source iterable.\n * @param {Iterable<T>} sourceIterable - The iterable to split into multiple iterators.\n * @param {number} count - The number of independent iterators to create.\n * @returns {IterableIterator<T>[]} An array of independent iterators over the source iterable.\n * @throws {Error} If incorrect arguments are provided or the source is not iterable.\n *\n * @example\n * const arr = [1, 2, 3, 4];\n * const [it1, it2] = Array.tee(arr, 2);\n * console.log(it1.next().value); // 1\n * console.log(it2.next().value); // 1\n * console.log(it1.next().value); // 2\n * console.log(it2.next().value); // 2\n */\nexport function createTeeIterators<T>(sourceIterable: Iterable<T>, count: number): IterableIterator<T>[] {\n    if(arguments.length !== 2) throw new Error(`Expected 2 arguments but recieved: ${arguments.length}`);\n    if(!sourceIterable[Symbol.iterator]) throw new Error(`Expected Arg 1 to be an iterator.`)\n    if(!(typeof count === \"number\")) throw new Error(`Expected Arg 2 to be an integer`)\n\n    // Make it an integer\n    count = Math.floor(count)\n\n    const sourceIterator = sourceIterable[Symbol.iterator]();\n    const iteratorIndexPositions: number[] = Array(count).fill(0);\n    const streamBuffer: T[] = []\n    \n    let streamExhausted = false;\n    let streamError: Error | null = null;\n\n    /**\n     * Gets the next value from the source iterator, handling exhaustion and errors.\n     */\n    function getNextStreamElement() {\n        if(streamExhausted) return { value: undefined, done: true};\n        if(streamError) throw streamError;\n\n        try {\n            const result = sourceIterator.next();\n            if(result.done) streamExhausted = true;\n            // console.log('result',result)\n            return result;\n        } catch(e) {\n            streamError = e as any as Error;\n            throw e\n        }  \n    }\n\n    /**\n     * Cleans up the buffer by removing elements already consumed by all iterators.\n     */\n    function cleanupStreamBuffer() {\n        const smallestComsumedIndex = Math.min(...iteratorIndexPositions)\n        const deletedElementsCount = smallestComsumedIndex;\n        streamBuffer.splice(0, deletedElementsCount);\n        for(let i = 0; i < count; i++) {\n            iteratorIndexPositions[i] -= deletedElementsCount;\n        }\n    }\n\n    /**\n     * Creates a single teed iterator for the given index.\n     */\n    function createTeedIterator(index: number): IterableIterator<T> {\n        let done = false\n        return {\n            [Symbol.iterator]() {\n                return this\n            },\n            next(): IteratorResult<T> {\n                if(done) return { value: undefined, done: true}\n\n                // console.log(`Before`)\n                // console.log(`iterator ${index}`)\n                // console.log(\"buffer\", streamBuffer)\n                // console.log(`index position: ${iteratorIndexPositions[index]}`)\n                \n                if(iteratorIndexPositions[index] < streamBuffer.length) {\n                    const value = streamBuffer[iteratorIndexPositions[index]];\n                    iteratorIndexPositions[index]++;\n                    cleanupStreamBuffer();\n                    return { value, done: false }\n                }\n\n                const result = getNextStreamElement()\n\n                if(result.done) {\n                    done = true;\n                    return {done: true, value: undefined}\n                }\n\n                // console.log(\"pushed to stream\");\n                streamBuffer.push(result.value!);\n                // console.log(\"index incremented\")\n                iteratorIndexPositions[index]++\n                cleanupStreamBuffer();\n\n                // console.log(\"After\")\n                // console.log(`iterator ${index}`)\n                // console.log(\"buffer\", streamBuffer)\n                // console.log(`index position: ${iteratorIndexPositions[index]}`)\n\n                return { value: result.value!, done: false }\n\n            },\n            return(value) {\n                if(!done) {\n                    done = true;\n                }\n                return { value, done}\n            },\n            throw(e) {\n                if(!done) {\n                    done = true;\n                }\n                throw e\n            }\n        }   \n    }\n\n    return Array(count).fill(0).map((_, idx) => createTeedIterator(idx))\n}\n\n\ntype ExtractReturnTypeFromFuncArray<T extends unknown[]> =\n  T extends  [infer First, ...infer Rest] ?\n    First extends (...args: any[]) => any ?\n      Rest extends ((...args: any[]) => any)[] ?\n        [ReturnType<First>, ...ExtractReturnTypeFromFuncArray<Rest>]\n      : never\n    : never\n  : [];\n\ntype ExtractFnFromTeeConsumer<T extends unknown[]> =\n    T extends [infer First, ...infer Rest] ?\n        First extends TeeConsumer<any,any> ?\n            Rest extends TeeConsumer<any,any>[] ?\n                [First['fn'], ...ExtractFnFromTeeConsumer<Rest>]\n            : never\n        : never\n    : [];\n\n// type TeeConsumerFn<T> = <T>(val: T, idx: number) => void\nexport type TeeConsumer<T,S=any> = {\n    fn: (val: T, idx: number) => S,\n    kind: 'map' \n} |\n{\n    fn: (val: T, idx: number) => boolean,\n    kind: 'filter'\n} | \n{\n    fn: (acc: S | number, curr: T, idx: number) => S | number,\n    kind: 'reduce',\n    initVal?: S | number \n} | \n{\n    fn: (val: T, idx: number) => void,\n    kind: 'forEach',\n};\n\ntype res = ExtractReturnTypeFromFuncArray<ExtractFnFromTeeConsumer<[\n    { fn: (val: number, idx: number) => string, kind: 'map'},\n    { fn: (acc: number, curr: number, idx: number) => number, kind: 'reduce', initVal?: number}\n]>>\n\n\n// type TeeConsumer<T,S=any> = TeeConsumerFn<T> | TeeConsumserConfigurable<T,S>\n\n /**\n * Applies multiple consumer operations (map, filter, reduce, forEach) in parallel to an array, using independent iterators for each consumer.\n * Each consumer receives elements and their index, and results are returned in an array matching the order of consumer\n * @throws {TypeError|Error} If invalid arguments or consumer configuration are provided.\n *\n * @example\n * const arr = [1,2,3];\n * const results = arr.tee(\n *   { kind: 'map', fn: (x, i) => x * 2 },\n *   { kind: 'filter', fn: (x, i) => x % 2 === 1 },\n *   { kind: 'reduce', fn: (acc, x, i) => acc + x, initVal: 0 },\n *   { kind: 'forEach', fn: (x, i) => console.log(x) }\n * );\n * // results: [[2,4,6], [1,3], 6, undefined]\n */\nexport function teeConsumers<T,S>(this: Array<T>, ...consumers: TeeConsumer<T,S>[]) {\n    // Runtime type checking for params\n    if (!Array.isArray(this)) {\n        throw new TypeError('teeConsumers must be called on an array');\n    }\n    if (!consumers.length) {\n        throw new Error('At least one consumer must be provided');\n    }\n    // Validate each consumer object\n    for (const consumer of consumers) {\n        if (typeof consumer !== 'object' || consumer === null) {\n            throw new TypeError('Each consumer must be an object');\n        }\n        if (!('kind' in consumer) || typeof consumer.kind !== 'string') {\n            throw new TypeError('Each consumer must have a string kind property');\n        }\n        if (typeof consumer.fn !== 'function') {\n            throw new TypeError('Each consumer must have a function fn property');\n        }\n        if (consumer.kind === 'reduce' && !('initVal' in consumer)) {\n            // Allow reduce without initVal\n        }\n    }\n\n    // Prepare iterators and results\n    const consumerFns = Array.from(consumers);\n    const outResults: any[] = Array(consumerFns.length).fill(0);\n    const iterators = createTeeIterators(this, consumerFns.length);\n\n    // Process each consumer in parallel\n    for (let consumerIdx = 0; consumerIdx < consumerFns.length; consumerIdx++) {\n        const fn = consumerFns[consumerIdx];\n        const mapResult: any[] = [];\n        let reduceResult: any = fn.kind === 'reduce' ? fn.initVal : undefined;\n        let filterResult: T[] = [];\n        let elementIdx = 0;\n        // Iterate through each element for this consumer\n        for(const elem of iterators[consumerIdx]) {\n            switch(fn.kind) {\n                case 'forEach':\n                    fn.fn(elem, elementIdx);\n                    break;\n                case 'map':\n                    {\n                        const val = fn.fn(elem, elementIdx);\n                        mapResult.push(val);\n                    }\n                    break;\n                case 'reduce':\n                    {\n                        if (elementIdx === 0 && reduceResult === undefined) {\n                            reduceResult = elem;\n                        } else {\n                            reduceResult = fn.fn(reduceResult, elem, elementIdx);\n                        }\n                    }\n                    break;\n                case 'filter':\n                    {\n                        if (fn.fn(elem, elementIdx))\n                            filterResult.push(elem);\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown consumer kind: ${String((fn as any).kind)}`);\n            }\n            elementIdx++;\n        }\n        // Store result for this consumer\n        switch(fn.kind) {\n            case 'forEach':\n                outResults[consumerIdx] = undefined;\n                break;\n            case 'reduce':\n                outResults[consumerIdx] = reduceResult;\n                break;\n            case 'map':\n                outResults[consumerIdx] = mapResult;\n                break;\n            case 'filter':\n                outResults[consumerIdx] = filterResult;\n                break;\n        }\n    }\n    // Return all results\n    return outResults as any[];\n}\n", "import {createTeeIterators} from './tee'\n\ntype MapFunc<T,S> = (x: T, idx: number) => S;\ntype FilterFunc<T,S extends any = any> = (x: T, idx: number) => boolean;\ntype ForEachFunc<T,S extends any = any> = (x: T, idx: number) => void;\ntype ReduceFunc<T,S> = (acc: S, curr: T, idx: number) => S;\n\n\ntype IteratorMethods<T,S extends any = any> = \n  MapFunc<T,S> |\n  FilterFunc<T,S> |\n  ForEachFunc<T,S> |\n  ReduceFunc<T,S> |\n  Iterator<T>\n\ntype ExtractMapTypeFromFunc<T extends unknown[]> =\n  T extends  [infer First, ...infer Rest] ?\n    First extends (...args: any[]) => any ?\n      Rest extends ((...args: any[]) => any)[] ?\n        [ReturnType<First>, ...ExtractMapTypeFromFunc<Rest>]\n      : never\n    : never\n  : [];\n\n// type rs3 = ExtractMapTypeFromFunc<[MapFunc<string, number>, ReduceFunc<number, { name: string}>]>\n\n// type x = [\n//   Iterator<number>,\n//   MapFunc<number, string>,\n// ]\n\n\ntype GetLast<T extends any[]> = T extends readonly [...any[], infer Last] ? \n  Last extends Iterator<infer P> ?\n    readonly [P,P] \n      : Last extends IteratorMethods<infer Q, infer R> ?\n        readonly [Q, R]\n      : never\n    : never;\n\ntype Push<T extends any[], S extends any> = [...T, S];\n\n\n// type LazyIterator<IterType, Methods extends IteratorMethods<any,any>[] = [Iterator<IterType>]> = {\n//   map<S>(cb: MapFunc<GetLast<Methods>[1],S>): LazyIterator<IterType, Push<Methods, MapFunc<GetLast<Methods>[1],S>>>;\n//   filter(cb: FilterFunc<GetLast<Methods>[1]>): LazyIterator<IterType, Push<Methods, FilterFunc<GetLast<Methods>[1],GetLast<Methods>[1]>>>;\n//   forEach(cb: ForEachFunc<GetLast<Methods>[1]>): LazyIterator<IterType, Push<Methods, ForEachFunc<GetLast<Methods>[1],GetLast<Methods>[1]>>>;\n//   reduce<S>(cb: ReduceFunc<GetLast<Methods>[1],S>, initVal: S): LazyIterator<IterType, Push<Methods, ReduceFunc<GetLast<Methods>[1],S>>>;\n//   collect(): GetLast<Methods>[1][]\n// }\n\nexport class LazyIterator<IterType, Methods extends IteratorMethods<any,any>[] = [Iterator<IterType>]> implements IterableIterator<IterType> {\n    iterator: Iterator<IterType>;\n    methods: {\n        fn: IteratorMethods<any,any>\n        kind: 'map' | 'reduce' | 'forEach' | 'filter',\n        initVal?: any\n    }[];\n\n    exhausted: boolean;\n    caughtError: Error | null;\n    index: number;\n\n    static from<T>(iter: Iterator<T> | Iterable<T>) {\n        if(iter === undefined || iter === null) throw new Error(\"LazyIterator cannot be created from null or undefined\");\n        if('next' in iter && typeof iter.next === 'function') {\n            return new LazyIterator<T>(iter)\n        }\n\n        if (typeof iter === 'object' && Symbol.iterator in iter) {\n            const iterator = (iter as Iterable<T>)[Symbol.iterator]();\n            return new LazyIterator<T>(iterator);\n        }\n\n        throw new Error(\"Couldn't create LazyIterator. no valid iterator\");\n    }\n\n    constructor(iterator: Iterator<IterType>) {\n        this.iterator = iterator;\n        this.methods = []\n        this.exhausted = false;\n        this.caughtError = null;\n        this.index = 0;\n    }\n\n    private executeFunctMethod<T>(method: {\n        fn: IteratorMethods<any,any>,\n        kind: 'map' | 'reduce' | 'forEach' | 'filter',\n        initVal?: any\n    }, val: T, index: number) {\n        switch(method.kind) {\n            case 'map':\n            case 'filter':\n            case 'forEach':\n                {\n                    const fn = method.fn as MapFunc<any,any> | FilterFunc<any,any> | ForEachFunc<any,any>;\n                    return fn(val, index)\n                }  \n            case 'reduce':\n                {\n                    const fn = method.fn as ReduceFunc<any,any>\n                    return fn({}, val, index)\n                }\n            default:\n                return {} as any\n        }\n    }\n\n    next(): IteratorResult<GetLast<Methods>[1],undefined> {\n        // if(this.methods.length === 0) return { done: true, value: undefined}; \n        if(this.exhausted) return { done: true, value: undefined} \n\n        while(true) {\n            const nextVal = this.iterator.next();\n        \n            if(nextVal.done) {\n                this.exhausted = true;\n                 return { done: true, value: undefined}\n            }\n\n            if(this.methods.length === 0) return { value: nextVal.value, done: false} as { value: GetLast<Methods>[1], done: false}\n\n            \n            let filterFail = false;\n            let a = nextVal.value;\n\n            for(let i = 0; i < this.methods.length; i++) {\n                let retVal = this.executeFunctMethod(this.methods[i], a, this.index)\n                \n                // console.log({ value: nextVal.value, retVal, kind: this.methods[i].kind});\n\n                if(this.methods[i].kind === 'map')\n                    a = retVal;\n                if(this.methods[i].kind === 'filter' && retVal === false) {\n                    filterFail = true;\n                    break\n                }\n            }\n\n\n            this.index++;\n\n            if(filterFail) continue;\n\n            return { done: false, value: a} as { value: GetLast<Methods>[1], done: false}\n        }\n        \n    }\n\n    return(value: any) {\n        if(!this.exhausted) {\n            this.exhausted = true;\n        }\n\n        return { value, done: this.exhausted }\n    }\n\n    throw(e: any) {\n        if(!this.exhausted) {\n            this.exhausted = true\n        }\n\n        return { done: this.exhausted, value: undefined}\n    }\n\n    [Symbol.iterator]() {\n        return this\n    } \n\n    map<S>(cb: MapFunc<GetLast<Methods>[1],S>) {\n        this.methods.push({\n            fn: cb,\n            kind: 'map'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, MapFunc<GetLast<Methods>[1],S>>>;\n    }\n\n    filter(cb: FilterFunc<GetLast<Methods>[1]>) {\n        this.methods.push({\n            fn: cb,\n            kind: 'filter'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, FilterFunc<GetLast<Methods>[1],GetLast<Methods>[1]>>>;\n    }\n\n    forEach(cb: ForEachFunc<GetLast<Methods>[1]>) {\n        this.methods.push({\n            fn: cb,\n            kind: 'forEach'\n        });\n\n        return this as unknown as LazyIterator<IterType, Push<Methods, ForEachFunc<GetLast<Methods>[1],GetLast<Methods>[1]>>>;\n    }\n\n    reduce<S>(cb: ReduceFunc<GetLast<Methods>[1],S>, initVal: S) {\n        this.methods.push({\n            fn: cb,\n            kind: 'reduce',\n            initVal\n        })\n\n        const lazyIterator = this as unknown as LazyIterator<IterType, Push<Methods, ReduceFunc<GetLast<Methods>[1],S>>>\n\n        const reduceExec = new ReduceExecutor(lazyIterator);\n\n        return reduceExec;\n    }\n\n    toArray(): GetLast<Methods>[1][] {\n        return this.collect()\n    }\n\n    tee(count: number) {\n        return createTeeIterators<GetLast<Methods>[1]>(this, count).map(v => LazyIterator.from(v))\n    }\n\n    collect(): GetLast<Methods>[1][] {\n        const out: GetLast<Methods>[] = []\n        for(const elem of this) {\n            out.push(elem)\n        }\n        return out\n    }\n\n    take(n: number): GetLast<Methods>[1][] {\n        if (typeof n !== 'number' || n < 0) throw new Error('take(n): n must be a non-negative number');\n        const out: GetLast<Methods>[1][] = [];\n        let count = 0;\n        for (const elem of this) {\n            if (count++ >= n) break;\n            out.push(elem);\n        }\n        return out;\n    }\n\n    drop(n: number): GetLast<Methods>[1][] {\n        if (typeof n !== 'number' || n < 0) throw new Error('drop(n): n must be a non-negative number');\n        const out: GetLast<Methods>[1][] = [];\n        let count = 0;\n        for (const elem of this) {\n            if (count++ < n) continue;\n            out.push(elem);\n        }\n        return out;\n    }\n\n    takeWhile(predicate: (x: GetLast<Methods>[1], idx: number) => boolean): GetLast<Methods>[1][] {\n        const out: GetLast<Methods>[1][] = [];\n        let idx = 0;\n        for (const elem of this) {\n            if (!predicate(elem, idx)) break;\n            out.push(elem);\n            idx++;\n        }\n        return out;\n    }\n\n    dropWhile(predicate: (x: GetLast<Methods>[1], idx: number) => boolean): GetLast<Methods>[1][] {\n        const out: GetLast<Methods>[1][] = [];\n        let idx = 0;\n        let dropping = true;\n        for (const elem of this) {\n            if (dropping && predicate(elem, idx)) {\n                idx++;\n                continue;\n            }\n            dropping = false;\n            out.push(elem);\n            idx++;\n        }\n        return out;\n    }\n}\n\ntype ExtractLazyIteratorMethods<T extends unknown> =\n    T extends LazyIterator<infer _, infer Q> \n    ? Q\n    : never;\n\n\nclass ReduceExecutor<R extends any, S extends IteratorMethods<any,any>, T extends LazyIterator<R, S[]>> {\n    private lazyIterator: T;\n\n    constructor(lazyIterator: T) {\n        this.lazyIterator = lazyIterator;\n    }\n\n    execute() {\n        const reduceMethod = this.lazyIterator.methods.at(-1)!;\n        this.lazyIterator.methods.slice(0,-1);\n        const array = this.lazyIterator.collect();\n        const result = array.reduce(reduceMethod.fn as unknown as ReduceFunc<GetLast<ExtractLazyIteratorMethods<T>>[0],GetLast<ExtractLazyIteratorMethods<T>>[1]>, reduceMethod.initVal);\n        return result as unknown as GetLast<ExtractLazyIteratorMethods<T>>[1]\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
